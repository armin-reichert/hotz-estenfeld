\section{Closure properties of $ALG(X^*)$}

In the last section we defined $ALG(X^*)$ as the class of languages over an
alphabet $X$ accepted by a pushdown automaton.

The name ''algebraic languages'' remembers the fact that these languages can be
defined as the solution of equation systems with non-commutative variables using
formal power series. See for example \cite{SaSo} or \cite{Berstel77}.

We will prove for $ALG(X^*)$ similar closure properties as for $REG(X^*)$.

In this section we assume without loss of generality that the pushdown automata
have the following properties:

$card(S) = card(F) = 1$ and no edge ends in a start state and no edge leaves a
final state. Additionally, all edges labels have length 0 or 1, $\alpha(e) \leq
1,\ e \in E$.

In a very easy way one gets

\begin{theorem}[Closure under monoid homomorphism]
\label{alg-lang-closure-hom}
Let $\phi : X^* \to Y^*$ be a monoid homomorphism.
\[ L \in ALG(X^*) \Rightarrow \phi(L) \in ALG(Y^*) \]
\end{theorem} 

\begin{proof}
$L \in ALG(X^*) \Rightarrow$ there exists a PDA $\kappa = (\fa{A}, \pdstore{K})$
with $L_{\kappa} = L$. Replace $\alpha$ by $\alpha' := \alpha \circ \phi$ in
the definition of $\fa{A}$. 

For
\[ \fa{A'} = (G, Y, S, F, \alpha') \]
the PDA $\kappa' = (\fa{A'}, \pdstore{K})$ accepts $\phi(L_{\kappa}) = \phi(L)$.
\end{proof}

\transrem{I changed names in the following proof for better readability.}

\bigskip
\begin{theorem}
$ALG(X^*)$ is closed under union, concatenation and Kleene-star.
\end{theorem}

{\em Closure under union:}
\[ L_1, L_2 \in ALG(X^*) \Rightarrow L_1 \cup L_2 \in ALG(X^*) \]
\begin{proof}
Let
\[ \kappa_1 = (\fa{A}_1,\pdstore{K}_1),\quad \fa{A}_1 = (G_1, X,
\setof{s_1}, \setof{f_1}, \alpha_1),\quad G_1 = (V_1, E_1),\quad \pdstore{K}_1 =
(X, Y_1, \delta_1)
\]
and
\[ \kappa_2 = (\fa{A}_2,\pdstore{K}_2),\quad \fa{A}_2 = (G_2, X,
\setof{s_2}, \setof{f_2}, \alpha_2),\quad G_2 = (V_2, E_2),\quad \pdstore{K}_2 =
(X, Y_2, \delta_2)
\]
be pushdown automata accepting $L_1$ resp.\ $L_2$.

We may assume that $Y_1 \cap Y_2 = \emptyset,\ E_1 \cap E_2 =
\emptyset,\ V_1 \cap V_2 = \setof{s_1, f_2}$ where $s_1 = s_2$ and $f_1 = f_2$.

Define the PDA $\kappa_1 \cup \kappa_2$ by
\[ \fa{A}_1 \cup \fa{A}_2 := (G_1 \cup G_2, X, \setof{s_1}, \setof{f_2},
\alpha_1 \cup \alpha_2) \]
and pushdown store
\[ \pdstore{K}_1 \cup \pdstore{K}_2 := (E_1 \cup E_2, Y_1 \cup Y_2 \cup
\setof{\infty}, \delta_1 \cup \delta_2) \]
where
\[ (\delta_1 \cup \delta_2)(e, y) = \begin{cases}
\delta_1(e, y) & e \in E_1,\ y \in Y_1 \cup \setof{\epsilon} \\ 
\delta_2(e, y) & e \in E_2,\ y \in Y_2 \cup \setof{\epsilon} \\
\infty\infty & \text{else} 
\end{cases}
\]

The symbol $\infty$ is only introduced to make $\delta_1 \cup \delta_2$
complete. If $\infty$ is on-top of the pushdown store, then this cannot become
empty anymore. In that way it will become impossible to ''mix'' words from both
languages.

It holds: $L_{\kappa_1 \cup \kappa_2} = L_{\kappa_1} \cup L_{\kappa_2}$
(exercise).

The following figure shows our construction:

FIGURE

\end{proof}

{\em Closure under complex product:}
\[ L_1, L_2 \in ALG(X^*) \Rightarrow L_1 \cdot L_2 \in ALG(X^*) \]
\begin{proof}
We construct the PDA $\kappa = (\fa{A}, \pdstore{K})$ with 
\[\fa{A} = (G, X, \setof{s_1}, \setof{f_2}, \alpha)\]
where
\begin{eqnarray*}
G &=& (V, E) \\
V &=& V_1 \cup V_2 \cup \setof{p},\ p \notin V_1 \cup V_2 \\
E &=& E_1 \cup E_2 \cup \setof{b_1, b_2},b_1, b_2 \notin E_1 \cup E_2
\end{eqnarray*}

For the new ''bridge'' edges $b_1, b_2$ it holds $b_1: f_1 \edge{\epsilon} p$
and $b_2: p \edge{\epsilon} s_2$.

The labeling of the graph $G$ is defined by 
\[ \alpha(e) = \begin{cases} 
\alpha_1(e) 	& e \in E_1 \\
\alpha_2(e) 	& e \in E_2 \\
\epsilon 			& e \in \setof{b_1, b_2} 
\end{cases}\]

FIGURE

The pushdown store $\pdstore{K} = (E, Y, \delta)$ is defined by
\[ Y = Y_1 \cup Y_2 \cup \setof{\Join, \infty} \text{ with }\setof{\Join, \infty} \cap
(Y_1 \cup Y_2) = \emptyset \]

\[ \delta(e, y) = \begin{cases}
\delta_1(e, y) 					& e \in E_1,\ y \in Y_1 \cup \setof{\epsilon} \\
\delta_2(e, y) 					& e \in E_2,\ y \in Y_2 \cup \setof{\epsilon} \\
y \cdot \Join 					& e = b_1,\ y \in Y \cup \setof{\epsilon} \\
\epsilon 								& e = b_2,\ y = \Join \\
\infty\infty 						& \text{else}
\end{cases}\]

We prove now that the pushdown automaton $\kappa$ defined in that way accepts
the complex product $L_1 \cdot L_2$.

''$L_1 \cdot L_2 \subset L_{\kappa}$'':

Let $w \in L_1 \cdot L_2$. Then there exists a factorization $w = w_1 \cdot
w_2,\ w_1 \in L_1, w_2 \in L_2$.

For $w_1$ there exists an accepting path $\pi_1 \in \pathcategory{G_1}(s_1,
f_1)$ with label $\alpha_1(\pi_1) = w_1$ and pushdown store computation
$\delta_1(w_1, \epsilon) = \epsilon$.

For $w_2$ there exists an accepting path $\pi_2 \in \pathcategory{G_2}(s_2,
f_2)$ with label $\alpha_2(\pi_2) = w_2$ and pushdown store computation
$\delta_2(w_2, \epsilon) = \epsilon$.

Consider the path $\pi = \pi_1 \circ b_1 \circ b_2 \circ \pi_2 \in
\pathcategory{G}(s_1, f_2)$.

It holds
\begin{eqnarray*}
\delta(\pi) &=& \delta(\pi_1 \circ b_1 \circ b_2 \circ \pi_2) \\
&=& \delta(b_1 \circ b_2 \circ \pi_2, \delta(\pi, \epsilon)) \\
&=& \delta(b_1 \circ b_2 \circ \pi_2, \epsilon) \\
&=& \delta(b_2 \circ \pi_2, \delta(b_1, \epsilon)) \\
&=& \delta(b_2 \circ \pi_2, \epsilon \cdot \Join) \\
&=& \delta(\pi_2, \delta(b_2, \Join)) \\
&=& \delta(\pi_2, \epsilon) \\
&=& \delta_2(\pi_2, \epsilon) \\
&=& \epsilon
\end{eqnarray*}

This means, the pushdown store computation for $\pi$ is accepting.

The label of path $\pi$ is
\begin{eqnarray*}
\alpha(\pi) &=& \alpha(\pi_1 \circ b_1 \circ b_2 \circ \pi_2) \\
&=& \alpha(\pi_1) \circ \alpha(b_1) \circ \alpha(b_1 \circ \alpha(\pi_2) \\
&=& w_1 \cdot \epsilon \cdot \epsilon \cdot w_2 \\
&=& w_1 \cdot w_2 \\
&=& w
\end{eqnarray*}

This proves $w \in L_{\kappa}$ and therefore $L_1 \cdot L_2 \subset L_{\kappa}$.

''$L_1 \cdot L_2 \supset L_{\kappa}$'':

Let $w \in L_{\kappa}$ be a word accepted by the PDA $\kappa$. Then there exists
a path $\pi \in \pathcategory{G}(s_1, f_2)$ with label $\alpha(\pi) = w$ and a
pushdown store computation $\delta(\pi, \epsilon) = \epsilon$.

The path $\pi$ has a unique factorization $\pi = \pi_1 \circ b_1 \circ b_2
\circ \pi_2$ with $\pi_1 \in \pathcategory{G_1}(s_1, f_1)$ and $\pi_2 \in
\pathcategory{s_2, f_2}$. 

Consider $\delta(\pi_1, \epsilon)$, the computation of the pushdown store on the
path prefix $\pi_1$:

Assume $\delta(\pi_1, \epsilon) \neq \epsilon$. Then $\delta(\pi_1 \circ b_1
\circ b_2 \circ \pi_2, \epsilon) = \delta_1(\pi, \epsilon)$

TODO clarify

For the path labels we have $\alpha_1(\pi_1) = w_1 \in L_1, \alpha_2(\pi_2) =
w_2 \in L_2$ and
\begin{eqnarray*}
\alpha(\pi) &=& \alpha(\pi_1 \cdot b_1 \cdot b_2 \cdot \alpha_2) \\
&=& \alpha(\pi_1) \cdot \epsilon \cdot \epsilon \cdot \alpha(\pi_2) \\
&=& w_1 \cdot w_2 \\
&=& w
\end{eqnarray*}

So $w \in L_1 \cdot L_2$ and $L_1 \cdot L_2 \supset L_{\kappa}$.
\end{proof}

{\em Closure under Kleene-star:}
\[ L \in ALG(X^*) \Rightarrow L^* \in ALG(X^*) \]
\begin{proof}
Let $\kappa = (\fa{A}, \pdstore{K})$ be a PDA accepting $L$. We construct a PDA
$\kappa'$ accepting $L^*$ as follows:
\[ \fa{A}' = (G, X, \setof{s}, \setof{f}, \alpha')\]
with
\begin{eqnarray*}
G' &=& (V', E') \\
V' &=& V \cup \setof{p, q},\ \setof{p, q} \cap E = \emptyset \\
E' &=& E \cup \setof{e_0, e_0', e_1, e_1'},\ \setof{e_0, e_0', e_1, e_1'} \cap E
= \emptyset \\
\end{eqnarray*}

The new edges have the following source, target states and labeling:
\begin{eqnarray*}
& e_0: s \edge{\epsilon} p \\
& e_0': s \edge{\epsilon} f \\
& e_1: f \edge{\epsilon} q \\
& e_1': q \edge{\epsilon} s \\
\end{eqnarray*}

FIGURE

The pushdown store $\pdstore{K}' = (E', Y', \delta')$ is defined by $Y' = Y
\cup \setof{y', y'', \infty}$ where $\setof{y', y'', \infty} \cap Y =
\emptyset$ and $\delta'$ defined by
\[ \delta'(e, y) = \begin{cases}
\delta(e, y)		& e \in E,\ y \in  Y \cup \setof{\epsilon} \\
y'							& e = e_0,\ y = \epsilon \\
\epsilon				& e = e_0',\ y = y' \\
y''							& e = e_1,\ y = \epsilon \\
\epsilon				& e = e_1',\ y = y'' \\
\infty\infty		& \text{else}
\end{cases}\]

For the so defined PDA $\kappa'$ we show $L^* = L_{\kappa'}$.

''$L^* \subset L_{\kappa}$'':

Let $w \in L^*$, then we have two cases:

\begin{enumerate}
  \item $w = \epsilon$: Then there exists the path $\pi = e_0 \circ e_0' \in
  \pathcategory{G'}(s, f)$ with label $\alpha(\pi) = \epsilon$ and
  pushdown computation $\delta'(\pi) = \epsilon$.
  \item $w \neq \epsilon$: Then there exists a factorization $w = w_1 \cdots
  w_k,\ w_i \in L$ and paths $\pi \in \pathcategory{G}(s, f)$ with labels
  $\alpha(\pi_i) = w_i$ and pushdown computations $\delta(\pi, \epsilon) =
  \epsilon,\ i = 1, \ldots, k$.
  
  Consider the path $\pi = \pi_1 \circ e_1 \circ e_1' \circ \pi_2 \circ e_1
  \circ e_1' \ldots \circ e_1 \circ e_1' \circ \pi_k \in \pathcategory{G'}(s,
  f)$.
  
  It holds
  \begin{eqnarray*}
  \alpha(\pi) &=& \alpha(\pi_1) \cdot \alpha(e_1 \circ e_1') \cdot \alpha(\pi_2)
  \cdots \alpha(e_1 \circ e_1') \cdot \alpha(\pi_k) \\
  &=& \alpha(\pi_1) \cdot \epsilon \cdot \alpha(\pi_2) \cdots \epsilon \cdot
  \alpha(\pi_k)  \\
  &=& w_1 \cdots w_k = w
  \end{eqnarray*}
  
  For the pushdown computation holds:
  \begin{eqnarray*}
  \delta'(\pi, \epsilon) &=& \delta'(e_1 \circ e_1' \circ \pi_2 \ldots \pi_k,
  \delta(\pi_1, \epsilon)) \\
  &=& \delta'(e_1' \circ \pi_2 \ldots \pi_k, y'') = \delta'(\pi_2 \ldots \pi_k,
  \epsilon) \\
  &\ldots& \\
  &=& \delta'(\pi_k, \epsilon) = \delta(\pi_k, \epsilon) = \epsilon
  \end{eqnarray*}
 
  From this follows $w \in L_{\kappa'}$.
\end{enumerate} 
 
''$L^* \supset L_{\kappa}$'':

Let $w \in L_{\kappa'}$ be a word accepted by the PDA $\kappa'$. Then there
exists a path $\pi \in \pathcategory{G'}(s, f)$ with label $\alpha'(\pi) = w$
and pushdown computation $\delta'(\pi, \epsilon) = \epsilon$.

\begin{enumerate}
  \item $\pi = e_0 \circ e_0',\ \alpha'(\pi) = \epsilon,\ \delta'(\pi, \epsilon)
  = \epsilon \Rightarrow \epsilon \in L^*$.
  
  \item Given a factorization $\pi = \pi_1 \circ e_1 \circ e_1' \circ \pi_2 \circ e_1
  \circ e_1' \ldots \circ e_1 \circ e_1' \circ \pi_k$ with $\pi_i \in
  \pathcategory{G}(s, f)$ and edges $e_1, e_1'$ as constructed.
  
  Claim: $\delta'(\pi, \epsilon) = \epsilon \Rightarrow \delta(\pi_1, \epsilon)
  = \epsilon$
  
  Assumption: $\delta(\pi, \epsilon) \neq \epsilon$. Then by definition of
  $\delta'$ it holds $\delta'(e_1, \delta(\pi_1, \epsilon)) = \infty\infty$ and
  because $\delta'(e, \infty) = \infty\infty$ the pushdown store will never
  become empty, therefore $\delta'(\pi, \epsilon) \neq \epsilon$.
  
  This holds inductively for the paths $\pi_i,\ i = 1, \ldots k$. We get
  \begin{eqnarray*}
  \delta'(\pi, \epsilon) &=& \delta'(\pi_1 \circ e_1 \circ e_1' \circ \pi_2
  \ldots \pi_k, \epsilon) \Rightarrow \\
  \delta'(\pi_1, \epsilon) &=& \epsilon \\
  \delta'(\pi_1 \circ e_1 \circ e_1', \epsilon) &=& \delta'(e_1 \circ e_1',
  \delta(\pi_1, \epsilon)) = \delta'(e_1', y'') = \epsilon
  \end{eqnarray*}
  and for all $i = 1, \ldots, k:\ \delta'(\pi_i, \epsilon) = \epsilon$. 
  
  It holds $\alpha(\pi_i) = w_i \in L,\ i = 1, \ldots, k$.
  
  $\alpha'(\pi_1 \circ e_1 \circ e_1' \circ \pi_2 \ldots \pi_k) = \alpha(\pi_1)
  \cdot \epsilon \ldots \epsilon \cdot \alpha(\pi_k) = w_1 \cdots w_k = w \in
  L^*$.
\end{enumerate}

This completes the proof of our theorem.
\end{proof}

\bigskip
\begin{theorem}[Closure under intersection with regular language]
\label{alg-lang-closure-reg-intersect}
\[ L \in ALG(X^*),\ R \in REG(X^*)\Rightarrow L \cap R \in ALG(X^*) \]
\end{theorem}

\begin{proof}
Let $\kappa = (\fa{A}, \pdstore{K})$ be a PDA with $L_{\kappa} = L$ and $\fa{B}$
a complete, deterministic finite automaton accepting $R$. At each vertex, a loop
labeled with $\epsilon$ should be attached.

We construct a finite automaton $\fa{C} = \fa{A} \times \fa{B}$ as we did for
the intersection of regular languages in chapter II.1. The graph of $\fa{C}$ is
$G = (V, E)$ where the vertex set $V$ is the cartesian product $V_{\fa{A}}
\times V_{\fa{B}}$ and the edges are defined by
\[ E = \setof{(e, e') \in E_{\fa{A}} \times E_{\fa{B}} \mid \alpha(e) =
\beta(e') } \]

Because $\fa{B}$ is complete and deterministic, it holds $L_{\fa{C}} =
L_{\fa{A}} \cap L_{\fa{B}}$.

Now let $\kappa' = (\fa{C}, \pdstore{K}')$ be a PDA with $\pdstore{K}' = (E,
Y, \delta')$ and $\delta'((e, e'), y) = \delta(e, y)$.
For a word $w \in L_{\kappa'}$ there exists a path $\pi \in
\pathcategory{G}(S, F)$ with label $\alpha(\pi) = w$ and pushdown store
computation $\delta'(\pi, \epsilon) = \delta(proj_1(\pi), \epsilon) = \epsilon$.
Here $proj_1(\pi)$ denotes the projection onto the first component of the
edge-pairs constituting the path $\pi$.

From this follows $w \in L_{\kappa} \cap L_{\fa{B}}$.

The opposite direction is clear because of the construction of PDA $\kappa'$.
\end{proof}

\bigskip
\begin{theorem}[Closure under inverse homorphism]
\label{alg-lang-closure-inv-hom}
Let $\phi : X^* \to Y^*$ be a monoid homomorphism and $\phi(x) \in Y \cup
\setof{\epsilon}$. Then
\[ L \in ALG(Y^*) \Rightarrow \phi^{-1}(L) \in ALG(X^*) \]
\end{theorem}

\transrem{In the following proof some names have been changed and some comments
been added}

\begin{proof}
Let $\kappa = (\fa{A}, \pdstore{K})$ be a PDA accepting $L$. For the language
\[ \phi^{-1}(L) = \setof{w \in X^* \mid \phi(w) \in L} \]
we construct a PDA $\kappa' = (\fa{A}', \pdstore{K}')$ as follows (for
simplicity, we construct the graph and the pushdown store in parallel):

Let $\fa{A}$ be the finite automaton
\[ \fa{A} = (G, Y, S, F, \alpha),\quad G = (V, E) \]

Define
\[ \fa{A}' = (G', X, S, F, \alpha') \]
with graph $G' = (V', E')$.

1. Vertex set $V'$: In addition to the vertices of $V$, new vertices $r(v, x),\
x \in X$ are added which will be used to create cycles simulating the erasure of
symbols from $X$ by $\phi$.
\[ V' = V \cup \setof{r(v,x) \mid v \in V} \]

2. Edge set $E'$: For each symbol $x \in X$ which is mapped by $\phi$ to a 
symbol $y \in Y$, an edge is added to simulate the computation on $y$.
For each symbol $x \in X$ which is erased by $\phi$, two edges are added that
form a cycle simulating the computation on the empty word. Formally:

\begin{enumerate}
  \item Let $X[\to Y] := \setof{x \in X \mid \phi(x) \in Y}$. For each edge
  $e \in E$ labelled $y \in Y$ and each $x \in X[\to Y]$ an edge $e': Q(e)
  \edge{x} Z(e)$ is added to $E'$.
  
  \item Let $X[\to \epsilon] := \setof{x \in X \mid \phi(x) = \epsilon}$. For
  each vertex $v  \in V$ and each $x \in X[\to \epsilon]$ two edges $e'$ and
  $e''$ are added where
  \[ e': v \edge{x} r(v,x),\qquad e': r(v,x) \edge{\epsilon} v \]
  The pushdown store computation for $e', e''$ is defined by
  \[ \delta'(e', y) = y \$,\qquad \delta'(e'', \$) = \epsilon \]
  This means, when traversing edge $e'$, the symbol ${\$}$ is pushed onto the
  stack and popped again when $e''$ is traversed.
\end{enumerate}

The PDA $\kappa' = (\fa{A'}, \pdstore{K'})$ with pushdown store
$\pdstore{K'} = (E', Y \cup \setof{\$}, \delta')$ with $\delta'$ defined as
above accepts the language $\phi^{-1}(L)$ (exercise).
\end{proof}

Remark: The theorem also holds for arbitrary homomorphisms ($\phi(x) \in Y^*$).

\begin{corollary}
Let $\tau: X^* \to Y^*$ be a rational transduction. Then
\[ L\in ALG(X^*)\Rightarrow \tau(L)\in ALG(Y^*) \]
\end{corollary}

\begin{proof}
As shown in chapter II.5 we can write $\tau(L)$ as
\[ \tau(L)=\beta(\alpha^{-1}(L)\cap R) \]
where $\alpha : X^*\to Z^*, \beta: X^*\to Y^*$ are monoid homomorphisms and
$R\in REG(Z^*)$ is a regular language.

\begin{eqnarray*}
L\in ALG(X^*) &\Rightarrow& \alpha^{-1}(L)\in ALG(Z^*)\text{ by theorem
\ref{alg-lang-closure-inv-hom}}\\
&& \alpha^{-1}(L)\cap R\in ALG(Z^*)\text{ by theorem
\ref{alg-lang-closure-reg-intersect}}\\
&& \beta(\alpha^{-1(L)}\cap R)\in ALG(Y^*)\text{ by theorem
\ref{alg-lang-closure-hom}}
\end{eqnarray*}
\end{proof}

\bigskip
We want to prove another important closure property of the algebraic languages.
To do so, we introduce the notion of {\bf substitution}.

\begin{definition}
Let $X_\infty$ be a countably infinite alphabet (see chapter II.4), let $X
\subset X_\infty$ and $\sigma:X\to ALG(X_\infty^*)$ be a mapping.
$ALG(X_\infty^*)$ is a monoid with the complex product as its operation.

The continuation of $\sigma$ to a monoid homomorphism 
\[ \sigma: X^*\to ALG(X_\infty^*) \]
is called {\bf algebraic substitution}.
\end{definition}

It holds
\begin{theorem}
Let $L\in ALG(X^*)$ and $\sigma: X^*\to ALG(X_\infty^*)$ an algebraic
substitution. Then
\[ \sigma(L) := \setof{\sigma(w)\mid w\in L} \in ALG(X_\infty*) \]
\end{theorem}

\begin{proof}

\end{proof}

\bigskip
We have proved now the most important closure properties for algebraic
languages.

In the next section we investigate the theorem of Chomsky-Schützenberger,
another important theorem which gives a characterization of the algebraic languages.

{\bf Exercises:}

\begin{enumerate}
  \item Let $L\in ALG(X^*),\ R\in REG(X^*)$. Show:
  \[ LR^{-1}\in ALG(X^*)\text{ and }R^{-1}L\in ALG(X^*) \]
  
  \item For $L\in X^*$ let
  \begin{eqnarray*}
  INIT(L) &:=& \setof{u\mid uv\in L\text{ for }v\in X^*}\\
  FIN(L) &:=& \setof{u\mid vu\in L\text{ for }v\in X^*}\\
  SUBWORD(L) &:=& \setof{v\mid uvw\in L\text{ for }u,w\in X^*}
  \end{eqnarray*}
  Show: $L\in ALG(X^*) \Rightarrow INIT(L), FIN(L), SUBWORD(L)\in ALG(X^*)$.
  
  \item Show: There exist algebraic langauges $L_1, L_2\in ALG(X^*)$ such that
  $L_1^{-1} L_2 \notin ALG(X^*)$.
  
  Hint: Set $L_1 = a \setof{b^ia^i\mid i\geq 1}^*$ and $L_2 =
  \setof{a^{i}b^{2i}\mid i\geq 1}^*$. Prove that $L_1$ and $L_2$ are algebraic
  and take the intersection $(L_1^{-1}L_2)\cap b^+$. Then prove the following
  theorem: If $X$ contains a single element, then each algebraic language over
  $X$ is regular. From this the claim immediately follows.
\end{enumerate}
